[{:id "clamp"
  :instructions ["Write a function `clamp` to restrict a value to a given range:"

                 '(defn clamp [x min max]
                    )

                '(is (= 2 (clamp 2 1 4)))
                '(is (= 1 (clamp 0 1 4)))
                '(is (= 4 (clamp 5 1 4)))]
  :solution '(defn clamp [x min max]
               (cond
                 (<= min x max) x
                 (< x min) min
                 :else max))
  :uses #{'defn 'cond :math-comparisons}}


 {:id "triangle?"
  :instructions ["Write a function to determine if some 3 side lengths are sufficient to make a triangle."]
  :solution '(defn triangle? [a b c]
               (and (> a (+ b c))
                    (> b (+ a c))
                    (> c (+ a b))))
  :uses #{'and :math-operations :math-comparisons}}

 {:id "linear-interpolation"
  :instructions ["" ; TODO
                 "y = mx + b"]
  :solution '(defn interpolate [x [x0 x1] [y0 y1]]
               (let [m (/ (- y1 y0) (- x0 x1))
                     b (- y0 (* m x0))]
                 (+ (* m x) b)))
  :uses #{'let :destructuring :math-operations}}

 {:id "make-linear-interpolator"
  :instructions "" ; TODO
  :related #{"linear-interpolation"}
  :solution '(defn make-interpolator [[x0 x1] [y0 y1]]
               (let [m (/ (- y1 y0) (- x0 x1))
                     b (- y0 (* m x0))]
                 (fn [x]
                   (+ (* m x) b))))
  :uses #{'let :destructuring :math-operations :closure}}

 {:id "summing a list (apply)"
  :instructions ["Write a function to sum a list of numbers, using `apply`"]
  :related #{"summing a list (reduce)"
             "summing a list (atom)"
             "summing a list (naive recursion)"
             "summing a list (safe recursion)"}
  :solution '(defn sum [values]
               (apply + values))
  :uses #{'apply :math-operations}}

 {:id "summing a list (reduce)"
  :instructions ["Write a function to sum a list of numbers, using `reduce`"]
  :related #{"summing a list (apply)"
             "summing a list (atom)"
             "summing a list (naive recursion)"
             "summing a list (safe recursion)"}
  :solution '(defn sum [values]
               (reduce + values))
  :uses #{'reduce :math-operations}}

 {:id "summing a list (atom)"
  :instructions ["Write a function to sum a list of numbers, using an `atom` and `doseq`"]
  :related #{"summing a list (reduce)"
             "summing a list (apply)"
             "summing a list (naive recursion)"
             "summing a list (safe recursion)"}
  :solution '(defn sum [values]
               (let [total (atom 0)]
                 (doseq [v values]
                   (swap! total + v))
                 @total))
  :uses #{'let 'atom '@ 'swap! :working-with-atoms}}

 {:id "summing a list (naive recursion)"
  :instructions ["Write a function to sum a list of numbers, using recursion"]
  :related #{"summing a list (reduce)"
             "summing a list (apply)"
             "summing a list (atom)"
             "summing a list (safe recursion)"}
  :solution '(defn sum [values]
               (if (empty? values)
                 0
                 (+ (first values) (sum (rest values)))))
  :uses #{:recursion 'first 'rest 'empty? :math-operations 'if}}

 {:id "summing a list (safe recursion)"
  :instructions ["Write a function to sum a list of numbers, using recursion, but in a way that doesn't blow the stack."]
  :related #{"summing a list (reduce)"
             "summing a list (apply)"
             "summing a list (atom)"
             "summing a list (naive recursion)"}
  :solution ['(defn sum* [values accumulator]
                (if (empty? values)
                  accumulator
                  (recur (rest values) (+ (first values) accumulator))))

             '(defn sum [values]
                (sum* values 0))]
  :uses #{:recursion 'first 'rest 'recur 'empty? :math-operations 'if}}

 {:id "partial-map"
  :instructions ["Write a function that takes two functions and a list, then transforms the list by applying fn-a to values in the list that pass fn-b."]
  :solution '(defn partial-map [f pred? values]
               (map (fn [x]
                      (if (pred? x)
                        (f x)
                        x))
                    values))
  :uses #{'map 'if 'fn :higher-order-functions}}

{:id "measuring sort comparisons"
 :instructions [ "Explore how many comparisons it typically takes to sort a list."
                "Step 1: Create a function `sort-count`, that, given a list, returns the number of comparisons performed when sorting that list"
                "Step 2: Create a function `random-list` that returns a shuffled a list of values from 0 to N"
                "Step 3: Create a function `sort-frequencies` that uses the above two functions to run a number of trials, and then reports the relative frequencies of the number of comparisons needed."
                "For example, `(sort-frequencies 8 1000)` (1000 trials of 8 item list) gave the result:"
                [[12 0.001] [13 0.007] [14 0.026] [15 0.15] [16 0.342] [17 0.361] [18 0.113]]]
 :solution ['(defn sort-count [values]
               (let [comparisons (atom 0)]
                 (sort (fn [x y]
                         (swap! comparisons inc)
                         (compare x y)) values)
                 @comparisons))

            '(defn shuffled-list [n]
               (shuffle (range n)))

            '(defn sort-frequencies [list-length trial-count]
               (let [results (atom [])]
                 (dotimes [n trial-count]
                   (swap! results conj (sort-count (shuffled-list list-length))))
                 (->> (frequencies @results)
                      sort
                      (map (fn [[comparisons count]]
                             [comparisons (double (/ count trial-count))])))))]
 :uses #{:working-with-atoms 'atom 'swap! 'compare 'sort 'shuffle 'frequencies :destructuring '->> 'double 'count :math-operations '/}}
 ]
